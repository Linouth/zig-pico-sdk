const std = @import("std");

pub fn build(b: *std.build.Builder) !void {
    const pico_exe = try PicoExe.init(b, "testbin", "src/main.zig");
    const pico_exe_step = b.step("pico", "PicoExe test");
    pico_exe_step.dependOn(&pico_exe.step);

    pico_exe.install();

}

const PicoExe = struct {
    const base_id = .custom;

    step: std.build.Step,
    builder: *std.build.Builder,
    name: []const u8,
    zig_obj: *std.build.LibExeObjStep,

    output_bin: std.build.GeneratedFile,

    fn init(builder: *std.build.Builder, name_raw: []const u8, root_src: []const u8) !*PicoExe {
        // Check if the pico-sdk is cloned
        const build_root = std.fs.openDirAbsolute(builder.build_root, .{}) catch unreachable;
        try build_root.access("pico-sdk/src", .{});

        const name = builder.dupe(name_raw);

        const target = std.zig.CrossTarget{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        };
        const mode = builder.standardReleaseOptions();

        const obj = builder.addObject(name_raw, root_src);
        obj.setTarget(target);
        obj.setBuildMode(mode);

        // TODO: Add all the pico-sdk include dirs
        obj.addSystemIncludeDir("/usr/arm-none-eabi/include");
        // TODO: This include is tricky; find some way to have this generated by
        // cmake on compile
        obj.addSystemIncludeDir("pico-sdk/build/generated/pico_base");
        obj.addSystemIncludeDir("pico-sdk/src/common/pico_base/include");
        obj.addIncludeDir("pico-sdk/src/common/pico_stdlib/include");
        obj.addIncludeDir("pico-sdk/src/common/pico_time/include");
        obj.addIncludeDir("pico-sdk/src/rp2_common/pico_platform/include");
        obj.addIncludeDir("pico-sdk/src/rp2_common/pico_stdio/include");
        obj.addIncludeDir("pico-sdk/src/rp2_common/hardware_timer/include");
        obj.addIncludeDir("pico-sdk/src/rp2_common/hardware_base/include");
        obj.addIncludeDir("pico-sdk/src/rp2_common/hardware_gpio/include");
        obj.addIncludeDir("pico-sdk/src/rp2_common/hardware_uart/include");
        obj.addIncludeDir("pico-sdk/src/rp2040/hardware_regs/include");
        obj.addIncludeDir("pico-sdk/src/rp2040/hardware_structs/include");
        //obj.addIncludeDir("pico-sdk/src/rp2_common/hardware_gpio/include");

        const self = builder.allocator.create(PicoExe) catch unreachable;
        self.* = PicoExe {
            .builder = builder,
            .step = std.build.Step.init(base_id, name, builder.allocator, make),
            .name = name,
            .zig_obj = obj,
            .output_bin = .{ .step = &self.step },
        };

        self.step.dependOn(&obj.step);

        return self;
    }

    fn install(self: *PicoExe) void {
        const bin_install_step = self.builder.addInstallBinFile(
            std.build.FileSource{ .generated = &self.output_bin }, self.name
        );
        bin_install_step.step.dependOn(&self.step);

        self.builder.getInstallStep().dependOn(&bin_install_step.step);
    }

    fn make(step: *std.build.Step) !void {
        const self = @fieldParentPtr(PicoExe, "step", step);
        const builder = self.builder;

        const log = std.log.scoped(.PicoExe);

        const zig_obj_path = self.zig_obj.getOutputSource().getPath(builder);

        log.info("Creating build directory and CMakeLists file for the pico-sdk", .{});

        const build_root = try std.fs.openDirAbsolute(builder.build_root, .{});
        const cache_root = try build_root.openDir(builder.cache_root, .{});

        // Create build directory in cache, and CMakeLists.txt file
        cache_root.makePath("cmake/build") catch {};
        const cmake_dir = try cache_root.openDir("cmake", .{});
        const cmake_cfg = try cmake_dir.createFile("CMakeLists.txt", .{});
        defer cmake_cfg.close();

        // Fill in CMakeLists.txt file used by pico-sdk
        const writer = cmake_cfg.writer();
        try writer.print(
            \\cmake_minimum_required(VERSION 3.13)
            \\include(../../pico-sdk/pico_sdk_init.cmake)
            \\project({s})
            \\pico_sdk_init()
            \\add_executable({s})
            \\target_link_libraries({s} pico_stdlib {s})
            \\#pico_add_extra_outputs({s})
            , .{self.name, self.name, self.name, zig_obj_path, self.name}
        );

        var args = std.ArrayList([]const u8).init(builder.allocator);
        defer args.deinit();

        const cmake_path = builder.pathJoin(&.{builder.build_root, builder.cache_root, "cmake"});
        const build_path = builder.pathJoin(&.{cmake_path, "build"});

        // Running cmake command
        args.append("cmake") catch unreachable;
        args.append("-S") catch unreachable;
        args.append(cmake_path) catch unreachable;
        args.append("-B") catch unreachable;
        args.append(build_path) catch unreachable;

        log.info("Running cmake", .{});
        const cmake_out = try builder.execFromStep(args.items, &self.step);
        log.info("cmake outptut:\n{s}", .{cmake_out});

        // Running make command
        args.clearRetainingCapacity();
        args.append("make") catch unreachable;
        args.append("-C") catch unreachable;
        args.append(build_path) catch unreachable;

        log.info("Running make", .{});
        const make_out = try builder.execFromStep(args.items, &self.step);
        log.info("make output:\n{s}", .{make_out});

        // Add the generated elf file to the 'output_bin' GeneratedFile path
        const out_file = try std.fmt.allocPrint(builder.allocator, "{s}.elf", .{self.name});
        self.output_bin.path = builder.pathJoin(
            &.{ build_path, out_file }
        );

        log.info("Done!", .{});
    }
};
